package broadlink_client

import (
	"log"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestBroadlinkClient(t *testing.T) {
	c, err := NewClient()
	require.NoError(t, err)

	t.Run("getChecksum", func(t *testing.T) {
		payload := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xe8, 0x07, 0x26, 0x0b, 0x18, 0x02, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
		expectedChecksum := uint16(0xc00d)
		checksum := getChecksum(payload)
		require.Equal(t, expectedChecksum, checksum)

		payload = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
		expectedChecksum = uint16(0xbeaf)
		checksum = getChecksum(payload)
		require.Equal(t, expectedChecksum, checksum)

		payload = []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
		expectedChecksum = uint16(0xee7f)
		checksum = getChecksum(payload)
		require.Equal(t, expectedChecksum, checksum)

		payload = getPadding(0xff, 65)
		expectedChecksum = uint16(0xff6e)
		checksum = getChecksum(payload)
		require.Equal(t, expectedChecksum, checksum)

		payload = getPadding(0xff, 66)
		expectedChecksum = uint16(0x006d)
		checksum = getChecksum(payload)
		require.Equal(t, expectedChecksum, checksum)
	})

	t.Run("packTime", func(t *testing.T) {
		now, err := time.Parse(time.RFC3339Nano, "2024-02-20T11:57:44.797033+08:00")
		require.NoError(t, err)

		expectedPayload := []byte{0x08, 0x00, 0x00, 0x00, 0xe8, 0x07, 0x39, 0x0b, 0x18, 0x02, 0x14, 0x02}

		payload := packTime(now)

		require.Equal(t, expectedPayload, payload)
	})

	t.Run("getDiscoveryPacket", func(t *testing.T) {
		now, err := time.Parse(time.RFC3339Nano, "2024-02-20T11:57:44.797033+08:00")
		require.NoError(t, err)

		expectedPayload := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xe8, 0x07, 0x39, 0x0b, 0x18, 0x02, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

		payload, err := getDiscoveryPayload(now, c.sourceAddr, 1)
		require.NoError(t, err)

		require.Equal(t, len(payload), len(expectedPayload))
		require.Equal(t, expectedPayload[:0x1c], payload[:0x1c])
		require.Equal(t, expectedPayload[0x26:0x28], payload[0x26:0x28])
		require.Equal(t, expectedPayload[0x29], payload[0x29])
	})

	t.Run("getNextSequenceNumber", func(t *testing.T) {
		for i := 0; i < 65536; i++ {
			nextSequenceNumber := c.getNextSequenceNumber()
			log.Printf("%#+v", nextSequenceNumber)
		}

		require.True(t, false)
	})
}
